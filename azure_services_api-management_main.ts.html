<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>azure/services/api-management/main.ts - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="main.css">
    <script src="scripts/nav.js" defer></script>
    
    <script src="scripts/commonNav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
</nav>

<div id="main">
    
    <h1 class="page-title">azure/services/api-management/main.ts</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { DataAzurermResourceGroup } from '@cdktf/provider-azurerm/lib/data-azurerm-resource-group'
import {
  DataAzurermApiManagement,
  DataAzurermApiManagementConfig,
} from '@cdktf/provider-azurerm/lib/data-azurerm-api-management'
import { ApiManagementCustomDomain } from '@cdktf/provider-azurerm/lib/api-management-custom-domain'
import { ApiManagement } from '@cdktf/provider-azurerm/lib/api-management'
import { ApiManagementApi } from '@cdktf/provider-azurerm/lib/api-management-api'
import { ApiManagementApiOperation } from '@cdktf/provider-azurerm/lib/api-management-api-operation'
import { ApiManagementApiOperationPolicy } from '@cdktf/provider-azurerm/lib/api-management-api-operation-policy'
import {
  ApiManagementLogger,
  ApiManagementLoggerApplicationInsights,
} from '@cdktf/provider-azurerm/lib/api-management-logger'
import { ApiManagementBackend } from '@cdktf/provider-azurerm/lib/api-management-backend'
import { ApiManagementRedisCache } from '@cdktf/provider-azurerm/lib/api-management-redis-cache'
import { RedisCache } from '@cdktf/provider-azurerm/lib/redis-cache'
import { CommonAzureConstruct } from '../../common'
import { createAzureTfOutput } from '../../utils'
import {
  ApiManagementProps,
  ApiManagementBackendProps,
  ApiManagementApiProps,
  ApiManagementCustomDomainProps,
} from './types'
import _ from 'lodash'

/**
 * @classdesc Provides operations on Azure Api Management
 * - A new instance of this class is injected into {@link CommonAzureConstruct} constructor.
 * - If a custom construct extends {@link CommonAzureConstruct}, an instance is available within the context.
 * @example
 * ```
 * import { CommonAzureConstruct, CommonAzureStackProps } from '@gradientedge/cdk-utils'
 *
 * class CustomConstruct extends CommonAzureConstruct {
 *   constructor(parent: Construct, id: string, props: CommonAzureStackProps) {
 *     super(parent, id, props)
 *     this.props = props
 *     this.apiManagementManager.createApiManagement('MyApiManagement', this, props)
 *   }
 * }
 * ```
 */
export class AzureApiManagementManager {
  /**
   * @summary Method to create a new api management
   * @param id scoped id of the resource
   * @param scope scope in which this resource is defined
   * @param props api management properties
   * @see [CDKTF Api management Module]{@link https://github.com/cdktf/cdktf-provider-azurerm/blob/main/docs/apiManagement.typescript.md}
   */
  public createApiManagement(
    id: string,
    scope: CommonAzureConstruct,
    props: ApiManagementProps,
    applicationInsightsKey?: ApiManagementLoggerApplicationInsights['instrumentationKey'],
    externalRedisCache?: RedisCache
  ) {
    if (!props) throw `Props undefined for ${id}`

    const resourceGroup = new DataAzurermResourceGroup(scope, `${id}-am-rg`, {
      name: scope.props.resourceGroupName
        ? scope.resourceNameFormatter.format(scope.props.resourceGroupName)
        : `${props.resourceGroupName}`,
    })

    if (!resourceGroup) throw `Resource group undefined for ${id}`

    const apiManagement = new ApiManagement(scope, `${id}-am`, {
      ...props,
      name: scope.resourceNameFormatter.format(props.name, scope.props.resourceNameOptions?.apiManagement),
      resourceGroupName: resourceGroup.name,
      tags: props.tags ?? {
        environment: scope.props.stage,
      },
    })

    if (applicationInsightsKey) {
      new ApiManagementLogger(scope, `${id}-am-logger`, {
        name: scope.resourceNameFormatter.format(props.name, scope.props.resourceNameOptions?.apiManagementLogger),
        resourceGroupName: resourceGroup.name,
        apiManagementName: apiManagement.name,
        applicationInsights: {
          instrumentationKey: applicationInsightsKey,
        },
      })
    }

    if (externalRedisCache) {
      new ApiManagementRedisCache(scope, `${id}-am-redis-cache`, {
        name: scope.resourceNameFormatter.format(props.name, scope.props.resourceNameOptions?.apiManagementRedisCache),
        apiManagementId: apiManagement.id,
        connectionString: externalRedisCache.primaryConnectionString,
        cacheLocation: externalRedisCache.location,
        redisCacheId: externalRedisCache.id,
      })
    }

    createAzureTfOutput(`${id}-apiManagementName`, scope, apiManagement.name)
    createAzureTfOutput(`${id}-apiManagementFriendlyUniqueId`, scope, apiManagement.friendlyUniqueId)
    createAzureTfOutput(`${id}-apiManagementId`, scope, apiManagement.id)

    return apiManagement
  }

  /**
   * @summary Method to resolve an api management
   * @param id scoped id of the resource
   * @param scope scope in which this resource is defined
   * @param props api management properties
   * @see [CDKTF Api management Module]{@link https://github.com/cdktf/cdktf-provider-azurerm/blob/main/docs/apiManagement.typescript.md}
   */
  public resolveApiManagement(id: string, scope: CommonAzureConstruct, props: DataAzurermApiManagementConfig) {
    if (!props) throw `Props undefined for ${id}`

    const resourceGroup = new DataAzurermResourceGroup(scope, `${id}-am-rg`, {
      name: scope.props.resourceGroupName
        ? scope.resourceNameFormatter.format(scope.props.resourceGroupName)
        : `${props.resourceGroupName}`,
    })

    if (!resourceGroup) throw `Resource group undefined for ${id}`

    const apiManagement = new DataAzurermApiManagement(scope, `${id}-am`, {
      ...props,
      name: scope.resourceNameFormatter.format(props.name, scope.props.resourceNameOptions?.dataAzurermApiManagement),
      resourceGroupName: scope.props.resourceGroupName
        ? `${scope.props.resourceGroupName}-${scope.props.stage}`
        : `${props.resourceGroupName}`,
    })

    return apiManagement
  }

  /**
   * @summary Method to create a new api management backend
   * @param id scoped id of the resource
   * @param scope scope in which this resource is defined
   * @param props api management backend properties
   * @see [CDKTF Api management Backend Module]{@link https://github.com/cdktf/cdktf-provider-azurerm/blob/main/docs/ApiManagementBackend.typescript.md}
   */
  public createApiManagementBackend(id: string, scope: CommonAzureConstruct, props: ApiManagementBackendProps) {
    if (!props) throw `Props undefined for ${id}`

    const apiManagementBackend = new ApiManagementBackend(scope, `${id}-am-be`, {
      ...props,
      name: scope.resourceNameFormatter.format(props.name, scope.props.resourceNameOptions?.apiManagementBackend),
      description: props.description ?? `Backend for ${props.name}-${scope.props.stage}`,
      protocol: props.protocol ?? 'http',
    })

    createAzureTfOutput(`${id}-apiManagementBackendName`, scope, apiManagementBackend.name)
    createAzureTfOutput(`${id}-apiManagementBackendFriendlyUniqueId`, scope, apiManagementBackend.friendlyUniqueId)
    createAzureTfOutput(`${id}-apiManagementBackendId`, scope, apiManagementBackend.id)

    return apiManagementBackend
  }

  /**
   * @summary Method to create a new api management api
   * @param id scoped id of the resource
   * @param scope scope in which this resource is defined
   * @param props api management api properties
   * @see [CDKTF Api management Api Module]{@link https://github.com/cdktf/cdktf-provider-azurerm/blob/main/docs/ApiManagementApi.typescript.md}
   */
  public createApiManagementApi(id: string, scope: CommonAzureConstruct, props: ApiManagementApiProps) {
    if (!props) throw `Props undefined for ${id}`

    const apiManagementApi = new ApiManagementApi(scope, `${id}-am-api`, {
      ...props,
      name: scope.resourceNameFormatter.format(props.name, scope.props.resourceNameOptions?.apiManagementApi),
      displayName: props.displayName ?? props.name,
      revision: props.revision ?? '1',
      protocols: props.protocols ?? ['https'],
    })

    createAzureTfOutput(`${id}-apiManagementApiName`, scope, apiManagementApi.name)
    createAzureTfOutput(`${id}-apiManagementApiFriendlyUniqueId`, scope, apiManagementApi.friendlyUniqueId)
    createAzureTfOutput(`${id}-apiManagementApiId`, scope, apiManagementApi.id)

    _.forEach(props.operations, operation => {
      const apimOperation = new ApiManagementApiOperation(
        scope,
        `${id}-apim-api-operation-${operation.displayName}-${operation.method}`,
        {
          operationId: `${operation.displayName}-${operation.method}`,
          method: operation.method.toUpperCase(),
          apiManagementName: apiManagementApi.apiManagementName,
          resourceGroupName: apiManagementApi.resourceGroupName,
          apiName: apiManagementApi.name,
          displayName: operation.displayName,
          urlTemplate: operation.urlTemplate,
          templateParameter: operation.templateParameter,
        }
      )

      createAzureTfOutput(
        `${id}-${operation.displayName}-${operation.method}-apimOperationOperationId`,
        scope,
        apimOperation.operationId
      )
      createAzureTfOutput(
        `${id}-${operation.displayName}-${operation.method}-apimOperationFriendlyUniqueId`,
        scope,
        apimOperation.friendlyUniqueId
      )
      createAzureTfOutput(`${id}-${operation.displayName}-${operation.method}-apimOperationId`, scope, apimOperation.id)

      // Define Caching Policy if enabled
      let cacheSetVariablePolicy = ''
      let cacheInvalidateInboundPolicy = ''
      let cacheSetInboundPolicy = ''
      let cacheSetOutboundPolicy = ''

      if (operation.caching) {
        cacheSetVariablePolicy = `&lt;!-- Generate a comprehensive custom cache key (without query params or Accept header) -->
              &lt;set-variable name="customCacheKey" value="@{
                  // Instance identification
                  
                  // API identification
                  string apiName = context.Api.Name.Replace(" ", "").ToLower();
                  string apiVersion = context.Api.Version ?? "v1";
                  
                  // Full path construction (without query parameters)
                  string fullPath = context.Request.Url.Path.ToLower();

                  // Query parameters
                  string query = context.Request.Url.QueryString.ToLower();

                  // Construct final cache key (no Accept header needed for JSON-only APIs)
                  return $"{apiName}:{apiVersion}:{fullPath}:{query}";
              }" />
              &lt;set-variable name="bypassCache" value="@(context.Request.Headers.GetValueOrDefault("X-Cache-Bypass", "false").ToLower())" />`

        if (operation.caching.enableCacheSet) {
          cacheSetInboundPolicy = `&lt;choose>
                  &lt;when condition="@((string)context.Variables["bypassCache"] != "true")">
                      &lt;!-- Attempt to retrieve cached response -->
                      &lt;cache-lookup-value key="@((string)context.Variables["customCacheKey"])" variable-name="cachedResponse" caching-type="${operation.caching.cachingType || 'prefer-external'}" />

                      &lt;!-- If cache hit, return cached response -->
                      &lt;choose>
                          &lt;when condition="@(context.Variables.ContainsKey("cachedResponse"))">
                              &lt;return-response>
                                  &lt;set-status code="200" reason="OK" />
                                  &lt;set-header name="Content-Type" exists-action="override">
                                      &lt;value>application/json&lt;/value>
                                  &lt;/set-header>
                                  &lt;set-header name="X-Apim-Cache-Status" exists-action="override">
                                      &lt;value>HIT&lt;/value>
                                  &lt;/set-header>
                                  &lt;set-header name="X-Apim-Cache-Key" exists-action="override">
                                      &lt;value>@((string)context.Variables["customCacheKey"])&lt;/value>
                                  &lt;/set-header>
                                  &lt;set-body>@((string)context.Variables["cachedResponse"])&lt;/set-body>
                              &lt;/return-response>
                          &lt;/when>
                      &lt;/choose>
                  &lt;/when>
                  &lt;when condition="@((string)context.Variables["bypassCache"] == "true")">
                      &lt;cache-remove-value key="@((string)context.Variables["customCacheKey"])" caching-type="${operation.caching.cachingType || 'prefer-external'}" />
                  &lt;/when>
              &lt;/choose>`
          cacheSetOutboundPolicy = `&lt;!-- Store the response body in cache -->
              &lt;choose>
                  &lt;when condition="@(context.Response.StatusCode == 200)">
                      &lt;cache-store-value key="@((string)context.Variables["customCacheKey"])" value="@(context.Response.Body.As&lt;string>(preserveContent: true))" duration="${operation.caching.ttlInSecs ?? 900}" caching-type="${operation.caching.cachingType || 'prefer-external'}" />
                      &lt;!-- Add cache status header -->
                      &lt;set-header name="X-Apim-Cache-Status" exists-action="override">
                          &lt;value>MISS&lt;/value>
                      &lt;/set-header>
                  &lt;/when>
              &lt;/choose>
              &lt;!-- Add debug headers -->
              &lt;set-header name="X-Apim-Cache-Key" exists-action="override">
                  &lt;value>@((string)context.Variables["customCacheKey"])&lt;/value>
              &lt;/set-header>
              &lt;set-header name="X-Apim-API-Name" exists-action="override">
                  &lt;value>@(context.Api.Name)&lt;/value>
              &lt;/set-header>`
        }

        if (operation.caching.enableCacheInvalidation) {
          cacheInvalidateInboundPolicy = `&lt;set-variable name="clearCache" value="@(context.Request.Headers.GetValueOrDefault("X-Apim-Clear-Cache", "false").ToLower())" />
              &lt;!-- Allow admin to clear specific cache entries -->
              &lt;choose>
                  &lt;when condition="@((string)context.Variables["clearCache"] == "true")">
                      &lt;cache-remove-value key="@((string)context.Variables["customCacheKey"])" caching-type="${operation.caching.cachingType || 'prefer-external'}" />
                      &lt;return-response>
                          &lt;set-status code="200" reason="OK" />
                          &lt;set-body>Cache entry removed successfully&lt;/set-body>
                      &lt;/return-response>
                  &lt;/when>
              &lt;/choose>`
        }
      }

      // Inject rate limiting policy (if configured)
      let rateLimitPolicy = ''
      if (props.rateLimit &amp;&amp; scope.props.subscriptionId) {
        rateLimitPolicy = `&lt;rate-limit-by-key calls="${props.rateLimit.calls}" renewal-period="${props.rateLimit.renewalPeriodInSecs}" counter-key="${scope.props.subscriptionId}-${apimOperation.operationId}"/>`
      }

      const policyXmlContent = `&lt;policies>
        &lt;inbound>
          &lt;base />
          ${rateLimitPolicy}
          ${cacheSetVariablePolicy}
          ${cacheInvalidateInboundPolicy}
          ${cacheSetInboundPolicy}
          ${props.commonInboundPolicyXml ?? ''}
        &lt;/inbound>
        &lt;backend>
          &lt;base />
        &lt;/backend>
        &lt;outbound>
          &lt;base />
          ${cacheSetOutboundPolicy}
          ${props.commonOutboundPolicyXml ?? ''}
        &lt;/outbound>
        &lt;on-error>
            &lt;base />
        &lt;/on-error>
      &lt;/policies>`

      const apimOperationPolicy = new ApiManagementApiOperationPolicy(
        scope,
        `${id}-apim-api-operation-policy-${operation.displayName}-${operation.method}`,
        {
          apiManagementName: apiManagementApi.apiManagementName,
          resourceGroupName: apiManagementApi.resourceGroupName,
          apiName: apiManagementApi.name,
          operationId: apimOperation.operationId,
          xmlContent: policyXmlContent,
        }
      )

      createAzureTfOutput(
        `${id}-${operation.displayName}-${operation.method}-apimOperationPolicyFriendlyUniqueId`,
        scope,
        apimOperationPolicy.friendlyUniqueId
      )
      createAzureTfOutput(
        `${id}-${operation.displayName}-${operation.method}-apimOperationPolicyId`,
        scope,
        apimOperationPolicy.id
      )
    })

    return apiManagementApi
  }

  /**
   * @summary Method to create a new api management custom domain
   * @param id scoped id of the resource
   * @param scope scope in which this resource is defined
   * @param props api management custom domain properties
   * @see [CDKTF Api management Custom Domain Module]{@link https://github.com/cdktf/cdktf-provider-azurerm/blob/main/docs/createApiManagementCustomDomain.typescript.md}
   */
  public createApiManagementCustomDomain(
    id: string,
    scope: CommonAzureConstruct,
    props: ApiManagementCustomDomainProps
  ) {
    if (!props) throw `Props undefined for ${id}`

    const apiManagementCustomDomain = new ApiManagementCustomDomain(scope, `${id}-am-cd`, props)

    createAzureTfOutput(
      `${id}-apiManagementCustomDomainFriendlyUniqueId`,
      scope,
      apiManagementCustomDomain.friendlyUniqueId
    )
    createAzureTfOutput(`${id}-apiManagementCustomDomainId`, scope, apiManagementCustomDomain.id)

    return apiManagementCustomDomain
  }
}
</code></pre>
        </article>
    </section>





    
</div>

<br class="clear">

<footer>
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>

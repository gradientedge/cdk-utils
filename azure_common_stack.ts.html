<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>azure/common/stack.ts - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="main.css">
    <script src="scripts/nav.js" defer></script>
    
    <script src="scripts/commonNav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
</nav>

<div id="main">
    
    <h1 class="page-title">azure/common/stack.ts</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { ComponentResource, ComponentResourceOptions, Config } from '@pulumi/pulumi'
import appRoot from 'app-root-path'
import fs from 'fs'
import _ from 'lodash'
import path from 'path'
import { isDevStage } from '../../common/index.js'
import { CommonAzureConstruct } from './construct.js'
import { registerTagTransformation } from './tagging.js'
import { CommonAzureStackProps } from './types.js'

/**
 * @classdesc Common stack to use as a base for all higher level constructs using Pulumi
 * @example
 * ```typescript
 * import { CommonAzureStack } from '@gradientedge/cdk-utils'
 *
 * class CustomStack extends CommonAzureStack {
 *   constructor(name: string, props: CommonAzureStackProps) {
 *     super(name, props)
 *     // provision resources
 *   }
 * }
 * ```
 */
export class CommonAzureStack extends ComponentResource {
  construct: CommonAzureConstruct
  props: CommonAzureStackProps
  config: Config

  constructor(name: string, props: CommonAzureStackProps, options?: ComponentResourceOptions) {
    super(`custom:azure:Stack:${name}`, name, props, options)

    /* initialise config */
    this.config = new Config()
    this.props = this.determineConstructProps(props)

    /* register tag transformation for automatic tag application */
    if (this.props.defaultTags) {
      registerTagTransformation(this.props.defaultTags)
    }
  }

  /**
   * @summary Method to determine the core construct properties injected via context
   * @param props The stack properties
   * @returns The stack properties
   */
  protected determineConstructProps(props: CommonAzureStackProps) {
    let projectProps: CommonAzureStackProps = props
    if (!projectProps) {
      const projectPropsPath = path.join(appRoot.path, 'pulumi.json')
      if (!fs.existsSync(projectPropsPath)) throw `Context properties unavailable in path:${projectPropsPath}`

      const projectPropsBuffer = fs.readFileSync(projectPropsPath)
      projectProps = JSON.parse(projectPropsBuffer.toString('utf-8'))
    }

    return {
      domainName: projectProps.domainName,
      extraContexts: projectProps.extraContexts,
      location: projectProps.location,
      name: projectProps.resourceGroupName ?? projectProps.name,
      resourceGroupName: projectProps.resourceGroupName,
      globalPrefix: projectProps.globalPrefix,
      globalSuffix: projectProps.globalSuffix,
      resourceNameOptions: projectProps.resourceNameOptions,
      resourcePrefix: projectProps.resourcePrefix,
      resourceSuffix: projectProps.resourceSuffix,
      skipStageForARecords: projectProps.skipStageForARecords,
      stage: projectProps.stage,
      stageContextPath: projectProps.stageContextPath,
      subDomain: projectProps.subDomain,
      subscriptionId: projectProps.subscriptionId,
      tenantId: projectProps.tenantId,
      clientId: projectProps.clientId,
      clientSecret: projectProps.clientSecret,
      defaultTags: projectProps.defaultTags,
      ...this.determineExtraContexts(props),
      ...this.determineStageContexts(props),
    }
  }

  /**
   * @summary Method to determine extra contexts apart from the main context
   * - Sets the properties from the extra contexts
   * - Primary use is to have layered config in separate files to enable easier maintenance and readability
   */
  protected determineExtraContexts(props: CommonAzureStackProps) {
    if (!props.extraContexts) {
      if (props.debug) console.debug(`No additional contexts provided. Using default context properties`)
      return {}
    }

    let extraContextProps: Record&lt;string, any> = {}
    _.forEach(props.extraContexts, (context: string) => {
      const extraContextPath = path.join(appRoot.path, context)

      /* scenario where extra context is configured but absent in file system */
      if (!fs.existsSync(extraContextPath)) throw `Extra context properties unavailable in path:${extraContextPath}`

      /* read the extra properties */
      const extraContextPropsBuffer = fs.readFileSync(extraContextPath)
      if (props.debug) console.debug(`Adding additional contexts provided in ${extraContextPath}`)

      /* parse as JSON properties */
      extraContextProps = {
        ...extraContextProps,
        ...JSON.parse(extraContextPropsBuffer.toString('utf-8')),
      }
    })
    return extraContextProps
  }

  /**
   * @summary Method to determine extra stage contexts apart from the main context
   * - Sets the properties from the extra stage contexts
   * - Primary use is to have layered config for each environment which is injected into the context
   */
  protected determineStageContexts(props: CommonAzureStackProps) {
    const stageContextFilePath = path.join(appRoot.path, props.stageContextPath ?? 'env', `${props.stage}.json`)

    if (isDevStage(props.stage)) {
      if (props.debug) console.debug(`Development stage. Using default stage context properties`)
    }

    /* alert default context usage when extra stage config is missing */
    if (!fs.existsSync(stageContextFilePath)) {
      if (props.debug) console.debug(`Stage specific context properties unavailable in path:${stageContextFilePath}`)
      if (props.debug) console.debug(`Using default stage context properties for ${props.stage} stage`)
      return {}
    }

    /* read the extra properties */
    const stageContextPropsBuffer = fs.readFileSync(stageContextFilePath)
    if (props.debug) console.debug(`Adding additional stage contexts provided in ${stageContextFilePath}`)

    /* parse as JSON properties */
    return JSON.parse(stageContextPropsBuffer.toString('utf-8'))
  }

  /**
   * @summary Determine the fully qualified domain name based on domainName &amp; subDomain
   */
  protected fullyQualifiedDomain() {
    const domainName = this.props.domainName
    const subDomain = this.props.subDomain

    return subDomain ? `${subDomain}.${domainName}` : domainName
  }
}
</code></pre>
        </article>
    </section>





    
</div>

<br class="clear">

<footer>
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
